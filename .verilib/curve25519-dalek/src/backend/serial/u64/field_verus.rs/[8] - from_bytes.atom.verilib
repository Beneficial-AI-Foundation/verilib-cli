    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)
        ensures
            // last bit is ignored
            as_nat(r.limbs) == as_nat_32_u8(*bytes) % pow2(255)
    {
        proof {
            l51_bit_mask_lt(); // No over/underflow in the below let-def
            assume(false);
        }
        let low_51_bit_mask = (1u64 << 51) - 1;
        // ADAPTED CODE LINE: limbs is now a named field
        FieldElement51{ limbs:
        // load bits [  0, 64), no shift
        [  load8_at(bytes,  0)        & low_51_bit_mask
        // load bits [ 48,112), shift to [ 51,112)
        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask
        // load bits [ 96,160), shift to [102,160)
        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask
        // load bits [152,216), shift to [153,216)
        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask
        // load bits [192,256), shift to [204,112)
        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask
        ]}
    }