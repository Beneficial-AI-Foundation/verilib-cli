{
  "code_name": "pow2_51_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_0_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_diff_factor",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/term_product_bounds",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow_nat_is_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/masked_lt_51",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_0_bounded",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val",
    "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/m",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_0_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_0_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_squared",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_div_and_mod_51",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/lemma_reorder_mul",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_0_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow2_square",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_shift_bounded",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_mul_sub",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_0_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_cast_then_mod_51",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_le"
  ],
  "disabled": false,
  "fingerprint": "9ec034b5c51d22de1dec21a5298524fda747bcb4c71e2723b9ccc74d95879059",
  "id": 460297,
  "identifier": "pow2k",
  "index": 9,
  "parent_id": 460287,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/pow2k",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            forall |i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p()\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n\n                // precond for term_product_bounds\n                assert( 19 * bound <= u64::MAX) by {\n                    assert( 19 * (1u64 << 54) <= u64::MAX) by (compute);\n                }\n                // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n                term_product_bounds(a, bound);\n\n                // ci_0 < 77 * (1u128 << 108)\n                c_i_0_bounded(a, bound);\n\n                // precond for c_i_shift_bounded\n                assert(77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n                    assert( 77 * (1u128 << 108)+ u64::MAX <= ((u64::MAX as u128) << 51)) by (compute);\n                }\n                // ci >> 51 <= u64::MAX\n                c_i_shift_bounded(a, bound);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // NOTE: we assert the properties derived from c_i_0_bounded\n                // and c_i_shift_bounded after every variable declaration,\n                // to trigger the solver instantiation\n\n                // ci_0 defs\n\n                let c0_0: u128 = c0_0_val(a); // a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19\n                assert(c0_0 < 77 * bound_sq);\n\n                let c1_0: u128 = c1_0_val(a); // a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19\n                assert(c1_0 < 59 * bound_sq);\n\n                let c2_0: u128 = c2_0_val(a); // a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19\n                assert(c2_0 < 41 * bound_sq);\n\n                let c3_0: u128 =  c3_0_val(a); // a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]\n                assert(c3_0 < 23 * bound_sq);\n\n                let c4_0: u128 =  c4_0_val(a); // a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]\n                assert(c4_0 < 5 * bound_sq);\n\n                // ci defs\n\n                let c1 = c1_val(a); // (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                assert((c1 >> 51) <= (u64::MAX as u128));\n\n                let c2 = c2_val(a); // (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                assert((c2 >> 51) <= (u64::MAX as u128));\n\n                let c3 = c3_val(a); // (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                assert((c3 >> 51) <= (u64::MAX as u128));\n\n                let c4 = c4_val(a); // (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                assert((c4 >> 51) <= (u64::MAX as u128));\n\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert(a0_0 + carry * 19 <= u64::MAX) by {\n                    assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                }\n\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        l51_bit_mask_lt();\n\n                        assert((pow2(51) as u64) == (pow2(51) as u128));\n\n                        assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                            lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n                        }\n\n                        assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n                        }\n\n                        assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n                        }\n\n                        assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n                        }\n\n                        assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n                        }\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        lemma_u128_shr_is_div(c0_0, 51);\n                        lemma_u128_shr_is_div(c1, 51);\n                        lemma_u128_shr_is_div(c2, 51);\n                        lemma_u128_shr_is_div(c3, 51);\n                        lemma_u128_shr_is_div(c4, 51);\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51) * c1_0) by {\n                            lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n                        }\n\n                        assert(pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2( 51) * c1 - pow2(102) * c2 + pow2(102) * c2_0) by {\n                            lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n                        }\n\n                        assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(153) * c3 + pow2(153) * c3_0) by {\n                            lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n                        }\n\n                        assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(204) * c4 + pow2(204) * c4_0) by {\n                            lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n                        }\n\n                        assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255) * carry) by {\n                            lemma_mul_is_distributive_sub(pow2(204) as int, c4 as int, pow2(51) * carry);\n                            lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, carry as int);\n                            lemma_pow2_adds(204, 51);\n                        }\n\n                        // carry on the right, get p\n                        assert(\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 +\n                            19 * carry - pow2(255) * carry\n                            ==\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 -\n                            p() * carry\n                        ) by {\n                            pow255_gt_19();\n                            lemma_mul_is_distributive_sub_other_way(carry as int, pow2(255) as int, 19);\n                        }\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}