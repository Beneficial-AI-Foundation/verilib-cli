    pub fn to_bytes(self) -> (r: [u8; 32])
        ensures
            // canonical encoding, i.e. mod p value
            as_nat_32_u8(r) == as_nat(self.limbs) % p()
    {
        proof {
            let l = spec_reduce(self.limbs);
            lemma_reduce(self.limbs);

            let q0 = (l[0] + 19) as u64 >> 51;
            let q1 = (l[1] + q0) as u64 >> 51;
            let q2 = (l[2] + q1) as u64 >> 51;
            let q3 = (l[3] + q2) as u64 >> 51;
            let q4 = (l[4] + q3) as u64 >> 51;

            assert(19 < (1u64 << 52)) by (bit_vector);
            lemma_add_then_shift(l[0], 19);
            lemma_add_then_shift(l[1], q0);
            lemma_add_then_shift(l[2], q1);
            lemma_add_then_shift(l[3], q2);
            lemma_add_then_shift(l[4], q3);

            let l0 = (l[0] + 19 * q4) as u64;
            let l1 = (l[1] + (l0 >> 51)) as u64;
            let l2 = (l[2] + (l1 >> 51)) as u64;
            let l3 = (l[3] + (l2 >> 51)) as u64;
            let l4 = (l[3] + (l3 >> 51)) as u64;

            assert( 19 * q4 < 1u64 << 7) by {
                // Explicit values for pow2(k) for k < 64
                lemma2_to64();
                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free
                shift_is_pow2(2);
                shift_is_pow2(7);
                lemma_pow2_adds(5, 2);
            }
            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);
            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);
            shifted_lt(l0, 51);
            shifted_lt(l1, 51);
            shifted_lt(l2, 51);
            shifted_lt(l3, 51);

            l51_bit_mask_lt();

            assume(false);

            // TODO
            // let rr = [
            //     l0 & LOW_51_BIT_MASK,
            //     l1 & LOW_51_BIT_MASK,
            //     l2 & LOW_51_BIT_MASK,
            //     l3 & LOW_51_BIT_MASK,
            //     l4 & LOW_51_BIT_MASK
            // ];

            // let r = [
            //     rr[0]                           as u8,
            //     (rr[0] >>  8)                    as u8,
            //     (rr[0] >> 16)                    as u8,
            //     (rr[0] >> 24)                    as u8,
            //     (rr[0] >> 32)                    as u8,
            //     (rr[0] >> 40)                    as u8,
            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,
            //     (rr[1] >>  5)                    as u8,
            //     (rr[1] >> 13)                    as u8,
            //     (rr[1] >> 21)                    as u8,
            //     (rr[1] >> 29)                    as u8,
            //     (rr[1] >> 37)                    as u8,
            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,
            //     (rr[2] >>  2)                    as u8,
            //     (rr[2] >> 10)                    as u8,
            //     (rr[2] >> 18)                    as u8,
            //     (rr[2] >> 26)                    as u8,
            //     (rr[2] >> 34)                    as u8,
            //     (rr[2] >> 42)                    as u8,
            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,
            //     (rr[3] >>  7)                    as u8,
            //     (rr[3] >> 15)                    as u8,
            //     (rr[3] >> 23)                    as u8,
            //     (rr[3] >> 31)                    as u8,
            //     (rr[3] >> 39)                    as u8,
            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,
            //     (rr[4] >>  4)                    as u8,
            //     (rr[4] >> 12)                    as u8,
            //     (rr[4] >> 20)                    as u8,
            //     (rr[4] >> 28)                    as u8,
            //     (rr[4] >> 36)                    as u8,
            //     (rr[4] >> 44)                    as u8
            // ];

        }
        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.
        //
        // Write h = pq + r with 0 <= r < p.
        //
        // We want to compute r = h mod p.
        //
        // If h < 2*p = 2^256 - 38,
        // then q = 0 or 1,
        //
        // with q = 0 when h < p
        //  and q = 1 when h >= p.
        //
        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.
        // Therefore q can be computed as the carry bit of h + 19.

        // First, reduce the limbs to ensure h < 2*p.
        let mut limbs = FieldElement51::reduce(self.limbs).limbs;

        let mut q = (limbs[0] + 19) >> 51;
        q = (limbs[1] + q) >> 51;
        q = (limbs[2] + q) >> 51;
        q = (limbs[3] + q) >> 51;
        q = (limbs[4] + q) >> 51;

        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q

        limbs[0] += 19 * q;

        // Now carry the result to compute r + 19q ...
        let low_51_bit_mask = (1u64 << 51) - 1;
        limbs[1] += limbs[0] >> 51;
        limbs[0] &= low_51_bit_mask;
        limbs[2] += limbs[1] >> 51;
        limbs[1] &= low_51_bit_mask;
        limbs[3] += limbs[2] >> 51;
        limbs[2] &= low_51_bit_mask;
        limbs[4] += limbs[3] >> 51;
        limbs[3] &= low_51_bit_mask;
        // ... but instead of carrying (limbs[4] >> 51) = 2^255q
        // into another limb, discard it, subtracting the value
        limbs[4] &= low_51_bit_mask;

        // Now arrange the bits of the limbs.
        let mut s = [0u8;32];
        s[ 0] =   limbs[0]                           as u8;
        s[ 1] =  (limbs[0] >>  8)                    as u8;
        s[ 2] =  (limbs[0] >> 16)                    as u8;
        s[ 3] =  (limbs[0] >> 24)                    as u8;
        s[ 4] =  (limbs[0] >> 32)                    as u8;
        s[ 5] =  (limbs[0] >> 40)                    as u8;
        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;
        s[ 7] =  (limbs[1] >>  5)                    as u8;
        s[ 8] =  (limbs[1] >> 13)                    as u8;
        s[ 9] =  (limbs[1] >> 21)                    as u8;
        s[10] =  (limbs[1] >> 29)                    as u8;
        s[11] =  (limbs[1] >> 37)                    as u8;
        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;
        s[13] =  (limbs[2] >>  2)                    as u8;
        s[14] =  (limbs[2] >> 10)                    as u8;
        s[15] =  (limbs[2] >> 18)                    as u8;
        s[16] =  (limbs[2] >> 26)                    as u8;
        s[17] =  (limbs[2] >> 34)                    as u8;
        s[18] =  (limbs[2] >> 42)                    as u8;
        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;
        s[20] =  (limbs[3] >>  7)                    as u8;
        s[21] =  (limbs[3] >> 15)                    as u8;
        s[22] =  (limbs[3] >> 23)                    as u8;
        s[23] =  (limbs[3] >> 31)                    as u8;
        s[24] =  (limbs[3] >> 39)                    as u8;
        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;
        s[26] =  (limbs[4] >>  4)                    as u8;
        s[27] =  (limbs[4] >> 12)                    as u8;
        s[28] =  (limbs[4] >> 20)                    as u8;
        s[29] =  (limbs[4] >> 28)                    as u8;
        s[30] =  (limbs[4] >> 36)                    as u8;
        s[31] =  (limbs[4] >> 44)                    as u8;

        // High bit should be zero.
        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS
        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);

        s
    }