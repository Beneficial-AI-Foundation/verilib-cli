{
  "code_name": "pow2_51_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/negate_proof",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/lemma_neg_no_underflow",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat"
  ],
  "disabled": false,
  "fingerprint": "cc6036c825da1f8490e73c3a4a593e2132bced87f776632109577ee969f06ad5",
  "id": 460288,
  "identifier": "negate",
  "index": 0,
  "parent_id": 460287,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/negate",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            negate_proof(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        self.limbs = neg.limbs;\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}