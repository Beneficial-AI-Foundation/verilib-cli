{
  "code_name": "pow2_51_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shifted_lt",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
    "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_add_then_shift",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat_32_u8",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p"
  ],
  "disabled": false,
  "fingerprint": "21a94c0fc186875355c915094980cc4c59f4c722f72e927c0508ef46baf40e99",
  "id": 460298,
  "identifier": "to_bytes",
  "index": 10,
  "parent_id": 460287,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/to_bytes",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            // canonical encoding, i.e. mod p value\n            as_nat_32_u8(r) == as_nat(self.limbs) % p()\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            assume(false);\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}