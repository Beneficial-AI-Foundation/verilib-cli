{
  "code_name": "pow2_51_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat_32_u8",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/load8_at"
  ],
  "disabled": false,
  "fingerprint": "b65fd9dd5b3c8d657659e6e8c4534514e5d84e4792f756e24a618cd7cd56ffb7",
  "id": 460296,
  "identifier": "from_bytes",
  "index": 8,
  "parent_id": 460287,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/from_bytes",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            // last bit is ignored\n            as_nat(r.limbs) == as_nat_32_u8(*bytes) % pow2(255)\n    {\n        proof {\n            l51_bit_mask_lt(); // No over/underflow in the below let-def\n            assume(false);\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}