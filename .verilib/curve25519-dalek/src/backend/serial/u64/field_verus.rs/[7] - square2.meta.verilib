{
  "code_name": "pow2_51_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/pow2k",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow_nat_is_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_k"
  ],
  "disabled": false,
  "fingerprint": "09cf68d28535eb0be61ae732c2e19a937d3151e7df98f021c2896d7649ac9ac0",
  "id": 460295,
  "identifier": "square2",
  "index": 7,
  "parent_id": 460287,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/square2",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p()\n    {\n        let mut square = self.pow2k(1);\n\n        // invisible to Rust, can be referenced in proofs\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall |i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() ==\n                ((2nat % p()) * (as_nat(square.limbs) % p())) % p()\n                ==\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n            ) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n                ==\n                (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p()\n            ) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall |j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall |j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall |j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}