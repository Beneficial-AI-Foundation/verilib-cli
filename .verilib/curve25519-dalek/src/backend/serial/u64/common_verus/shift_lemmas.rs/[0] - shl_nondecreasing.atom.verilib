pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)
    requires
        a <= b < 64,
        v * pow2(b) <= u64::MAX
    ensures
        (v << a) <= (v << b)
{
    lemma2_to64(); // pow2(0)

    if (a == b) {
        // trivial
    }
    else if (a == 0) {
        // a != b <=> b > 0
        lemma_pow2_strictly_increases(0, b);
        lemma_u64_shl_is_mul(v, 0);
        lemma_u64_shl_is_mul(v, b as u64);
        mul_le(v as nat, v as nat, pow2(0), pow2(b));
    }
    else {
        // if a != 0 and a != b then 0 < d < b
        let d = b - a;

        // v << b = (v << (b - a)) << a
        shl_decomposition(v, d as nat, a);

        assert(v << d == v * pow2(d as nat)) by {
            // we need the precond v * pow2(d) < M
            lemma_pow2_strictly_increases(d as nat, b);
            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));
            lemma_u64_shl_is_mul(v, d as u64);
        }

        assert(v <= v << d) by {
            shl_zero_is_id(v);
            lemma_u64_shl_is_mul(v, 0);
            lemma_pow2_strictly_increases(0, d as nat);
            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));
        }

        lemma_pow2_adds(a, d as nat);

        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {
            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);
        }

        // [v <= v << d] => [(v << a) <= (v << d) << a]
        lemma_shl_le_u64(v, v << (d as u64), a);
    }
}