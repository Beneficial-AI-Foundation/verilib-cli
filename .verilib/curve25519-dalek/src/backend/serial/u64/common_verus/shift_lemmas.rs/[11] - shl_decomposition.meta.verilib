{
  "code_name": "as_nat_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id"
  ],
  "disabled": false,
  "fingerprint": "df403965ea28436af2c88d851fb0e0ea44d6ce00f03d4dbb2b8fa8ce0d4d2c5d",
  "id": 460127,
  "identifier": "shl_decomposition",
  "index": 11,
  "parent_id": 460115,
  "path": "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}