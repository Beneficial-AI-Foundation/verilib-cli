{
  "code_name": "as_nat_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shl_le_u64",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition"
  ],
  "disabled": false,
  "fingerprint": "1bd345fd7e6123e4492dfce26cac84ce68540a3d8b5b0dc13e2e494ec6fbd6b5",
  "id": 460116,
  "identifier": "shl_nondecreasing",
  "index": 0,
  "parent_id": 460115,
  "path": "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_nondecreasing",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}