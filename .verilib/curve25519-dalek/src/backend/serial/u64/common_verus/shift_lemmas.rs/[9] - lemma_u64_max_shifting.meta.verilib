{
  "code_name": "as_nat_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_decomposition",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
  ],
  "disabled": false,
  "fingerprint": "7e8923d974ffbfa5a873f86d89076e5123f0857ac0e267989262ce9b487256c1",
  "id": 460125,
  "identifier": "lemma_u64_max_shifting",
  "index": 9,
  "parent_id": 460115,
  "path": "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_u64_max_shifting",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}