    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)
    requires
        limbs_bounded(a),
        limbs_bounded(b),
        to_nat(&a.limbs) < group_order(),
        to_nat(&b.limbs) < group_order(),
    ensures
        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),
    {
        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };
        proof { assert(1u64 << 52 > 0) by (bit_vector); }
        let mask = (1u64 << 52) - 1;

        // a + b
        let mut carry: u64 = 0;
        proof {
            // Base case: empty subrange has value 0
            assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) == 0);
            assert(seq_u64_to_nat(b.limbs@.subrange(0, 0 as int)) == 0);
            assert(seq_u64_to_nat(sum.limbs@.subrange(0, 0 as int)) == 0);
            assert((carry >> 52) == 0) by (bit_vector) requires carry == 0;
            lemma2_to64();
            assert(pow2(0) == 1);
        }
        for i in 0..5
           invariant
                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,
                    limbs_bounded(a),
                    limbs_bounded(b),
                    mask == (1u64 << 52) - 1,
                    i == 0 ==> carry == 0,
                    i >= 1 ==> (carry >> 52) < 2,
                    seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) ==
                    seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2((52 * (i) as nat))
        {
            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}
            let ghost old_carry = carry;
            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);
            let ghost sum_loop_start = sum;
            sum.limbs[i] = carry & mask;
            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));
            proof {
                lemma_add_loop_invariant(sum, carry, i, a, b, old_carry, mask, sum_loop_start);
            }
            proof {lemma_add_carry_and_sum_bounds(carry, mask);}
        }

        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) ==
               seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2((52 * (5) as nat)));

        proof {lemma_add_sum_simplify(a, b, &sum, carry);}

        // subtract l if the sum is >= l
        proof { lemma_l_value_properties(&constants::L, &sum); }
        assert(group_order() > to_nat(&sum.limbs) - group_order() >= -group_order());
        proof{lemma_l_equals_group_order();}
        proof{lemma_mod_sub_multiples_vanish(to_nat(&sum.limbs) as int, group_order() as int);}
        Scalar52::sub(&sum, &constants::L)

    }