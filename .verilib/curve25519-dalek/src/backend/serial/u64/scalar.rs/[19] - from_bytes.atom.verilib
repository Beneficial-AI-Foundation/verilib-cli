    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)
    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)
    {
        let mut words = [0u64; 4];
        for i in 0..4
            invariant 0 <= i <= 4 // proof
        {
            for j in 0..8
                invariant 0 <= j <= 8 && i < 4
            {
                proof {
                    assert(i < 4 && j < 8);
                    assert((i as u64)*8u64 < 32u64);
                    let idx = (i as u64) * 8 + (j as u64);
                    assert(idx < 32);
                }
                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);
            }
        }
        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)
        assume(bytes_to_nat(bytes) == words_to_nat(&words));
        proof {
            assert(1u64 << 52 > 0) by (bit_vector);
            assert(1u64 << 48 > 0) by (bit_vector);
            // TODO: prove property about words array
        }

        let mask = (1u64 << 52) - 1;
        let top_mask = (1u64 << 48) - 1;
        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };
        //test workflow graphs
        s.limbs[0] =   words[0]                            & mask;
        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;
        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;
        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;
        s.limbs[4] =  (words[3] >> 16)                     & top_mask;

        assume(false); // TODO: complete the proof

        s
    }