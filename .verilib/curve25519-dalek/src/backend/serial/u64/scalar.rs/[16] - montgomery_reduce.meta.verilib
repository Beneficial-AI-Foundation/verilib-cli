{
  "code_name": "mask_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/m",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/part1",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/part2",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
  ],
  "disabled": false,
  "fingerprint": "3b315fda7010ca2029a55da0de9fe6abcb1d93299ffb2dabc048211398228561",
  "id": 460169,
  "identifier": "montgomery_reduce",
  "index": 16,
  "parent_id": 460152,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}