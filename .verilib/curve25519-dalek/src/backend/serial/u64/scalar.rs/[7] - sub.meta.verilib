{
  "code_name": "mask_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_scalar_subtract_no_overflow",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop1_invariant",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_borrow_and_mask_bounded",
    "/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs/select",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_carry_bounded_after_mask",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop2_invariant",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_correct_after_loops"
  ],
  "disabled": false,
  "fingerprint": "184720927cf2f5520b06bacb56963b0f3def186cdb4fc26419ae8f5e1c9573a2",
  "id": 460160,
  "identifier": "sub",
  "index": 7,
  "parent_id": 460152,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // Without the following condition, all we can prove is something like:\n        // to_nat(&a.limbs) >= to_nat(&b.limbs) ==> to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n        // to_nat(&a.limbs) < to_nat(&b.limbs) ==> to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs) + pow2(260) + group_order()) % (pow2(260) as int),\n        // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n        limbs_bounded(&s),\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )));\n        assert( (borrow >> 63) == 0 ) by (bit_vector)\n            requires borrow == 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )) - (borrow >> 63) * pow2((52 * (0) as nat)));\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      limbs_bounded(a),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n                      seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int )) - (borrow >> 63) * pow2((52 * (i) as nat))\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            let ghost old_borrow = borrow;\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            let ghost difference_loop1_start = difference;\n            difference.limbs[i] = borrow & mask;\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            assert(\n            seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                        seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)));\n            proof{\n                lemma_sub_loop1_invariant(difference, borrow, i, a, b, old_borrow, mask, difference_loop1_start);\n            }\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n        // conditionally add l if the difference is negative\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        let mut carry: u64 = 0;\n        let ghost difference_after_loop1 = difference;\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) == 0);\n        assert(carry >> 52 == 0) by (bit_vector)\n            requires carry == 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      forall|j: int| i <= j < 5 ==> difference.limbs[j] == difference_after_loop1.limbs[j],\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n                      (i >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i-1],\n                      borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n                      borrow >> 63 == 1 ==>\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2(52 * i as nat)\n\n        {\n            let ghost old_carry = carry;\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            if borrow >> 63 == 0 {\n                assert(addend == 0);\n            }\n            if borrow >> 63 == 1 {\n                assert(addend == constants::L.limbs[i as int]);\n            }\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            let ghost difference_loop2_start = difference;\n            difference.limbs[i] = carry & mask;\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n                lemma_sub_loop2_invariant(difference, i, a, b, mask, difference_after_loop1, difference_loop2_start, carry, old_carry, addend, borrow);\n            }\n        }\n        proof { lemma_sub_correct_after_loops(difference, carry, a, b, difference_after_loop1, borrow);}\n        difference\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}