{
  "code_name": "mask_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat"
  ],
  "disabled": false,
  "fingerprint": "100fef61467ef69fdcc37befce296013f5c0c7a056f34671154a4f478dd1012a",
  "id": 460172,
  "identifier": "from_bytes",
  "index": 19,
  "parent_id": 460152,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_bytes",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}