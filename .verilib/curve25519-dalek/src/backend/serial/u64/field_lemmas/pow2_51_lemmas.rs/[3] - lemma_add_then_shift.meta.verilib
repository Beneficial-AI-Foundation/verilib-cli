{
  "code_name": "negate_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
  ],
  "disabled": false,
  "fingerprint": "e9445400f4d6d7dff0434f820515b399b7e549127e53ec0bab47b615d9874960",
  "id": 460196,
  "identifier": "lemma_add_then_shift",
  "index": 3,
  "parent_id": 460192,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_add_then_shift",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}