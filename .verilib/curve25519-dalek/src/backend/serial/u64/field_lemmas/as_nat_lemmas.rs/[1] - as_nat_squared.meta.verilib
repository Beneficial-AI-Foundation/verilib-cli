{
  "code_name": "load8_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_sum_factor",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_si_vi_and_reorder",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms_other_way",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_v0_and_reorder"
  ],
  "disabled": false,
  "fingerprint": "e1c1e8ab2cd8f477e72196925e269516159cc16a8e8afbbce367b203c4d8fae8",
  "id": 460262,
  "identifier": "as_nat_squared",
  "index": 1,
  "parent_id": 460260,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_squared",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 == s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        mul_5_terms_other_way(\n            as_nat(v) as int,\n            v0 as int,\n            s1 * v1,\n            s2 * v2,\n            s3 * v3,\n            s4 * v4\n        );\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        mul_v0_and_reorder(\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        );\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        mul_si_vi_and_reorder(\n            s1 as int, v1 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        mul_si_vi_and_reorder(\n            s2 as int, v2 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        mul_si_vi_and_reorder(\n            s3 as int, v3 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        mul_si_vi_and_reorder(\n            s4 as int, v4 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n\n        // s1 terms\n        assert(\n            s1 * (v0 * v1) + s1 * (v0 * v1)\n            ==\n            s1 * (2 * (v0 * v1))\n        ) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(\n            s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2)\n            ==\n            s2 * (v1 * v1 + 2 * (v0 * v2))\n        ) by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(\n            s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3)\n            ==\n            s3 * (2 * (v1 * v2) + 2 * (v0 * v3))\n        ) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(\n            s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            ==\n            s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))\n        ) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(\n            s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4)\n            ==\n            s5 * (2 * (v2 * v3) + 2 * (v1 * v4))\n        ) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(\n            s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4)\n            ==\n            s6 * (v3 * v3 + 2 * (v2 * v4))\n        ) by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(\n            s7 * (v3 * v4) + s7 * (v3 * v4)\n            ==\n            s7 * (2 * (v3 * v4))\n        ) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        // s3 terms\n        assert(\n            s8 * c3_x19 + s3 * c3_base\n            ==\n            s3 * (s5 * c3_x19 + c3_base)\n        ) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(\n            s7 * c2_x19 + s2 * c2_base\n            ==\n            s2 * (s5 * c2_x19 + c2_base)\n        ) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(\n            s6 * c1_x19 + s1 * c1_base\n            ==\n            s1 * (s5 * c1_x19 + c1_base)\n        ) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(\n            s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19\n            ==\n            p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 )\n        ) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19, c0_x19 as int);\n        }\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}