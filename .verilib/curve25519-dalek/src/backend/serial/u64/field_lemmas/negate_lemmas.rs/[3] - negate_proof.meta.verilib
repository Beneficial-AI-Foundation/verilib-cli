{
  "code_name": "variable_base.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/lemma_as_nat_sub",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_negate",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pre_reduce_limbs",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/lemma_neg_no_underflow",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shr_le_u64",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/all_neg_limbs_positive"
  ],
  "disabled": false,
  "fingerprint": "c80269493787205666cd10d88d4c96f1e3f7e4bde9142e814f2042e2fc19bc43",
  "id": 460226,
  "identifier": "negate_proof",
  "index": 3,
  "parent_id": 460222,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/negate_proof",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn negate_proof(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n        all_neg_limbs_positive(limbs)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_negate(limbs)[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, as_nat((c0, c, c, c, c)) = p, so\n        // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n        // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        as_nat(spec_negate(limbs)) == 16 * p() - as_nat(limbs) - p() * ((36028797018963952u64 - limbs[4]) as u64 >> 51),\n        (as_nat(spec_negate(limbs)) + as_nat(limbs)) % p() == 0\n{\n\n    lemma_reduce(pre_reduce_limbs(limbs));\n\n    let c0 = (pow2(51) - 19);\n    let c  = (pow2(51) - 1);\n    lemma2_to64_rest(); // get pow2(51)\n    // solver knows 36028797018963664u64 == 16 * c0\n    // solver knows 36028797018963952u64 == 16 * c;\n\n    lemma_neg_no_underflow(limbs);\n\n    // Introduce 16p as a vector\n    let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n    assert(as_nat(v) == 16 * p()) by {\n        // by definition of as_nat\n        assert( as_nat(v) ==\n            16 * c0 +\n            pow2(51) * (16 * c) +\n            pow2(102) * (16 * c) +\n            pow2(153) * (16 * c) +\n            pow2(204) * (16 * c)\n        );\n\n        // solver can reorder factors and pull out 16 on its own\n        // ...\n\n        // Write out `c`s and sum up powers\n        assert( p() ==\n            c0 +\n            pow2(51) * c +\n            pow2(102) * c +\n            pow2(153) * c +\n            pow2(204) * c\n        ) by {\n            lemma_pow2_adds(51, 51);\n            lemma_pow2_adds(51, 102);\n            lemma_pow2_adds(51, 153);\n            lemma_pow2_adds(51, 204);\n        }\n    }\n\n    let l0 = limbs[0];\n    let l1 = limbs[1];\n    let l2 = limbs[2];\n    let l3 = limbs[3];\n    let l4 = limbs[4];\n\n    assert(as_nat([\n        (16 * c0 - l0) as u64,\n        (16 * c - l1) as u64,\n        (16 * c - l2) as u64,\n        (16 * c - l3) as u64,\n        (16 * c - l4) as u64,\n        ]) == as_nat(v) - as_nat(limbs)\n    ) by {\n        lemma_as_nat_sub(v, limbs);\n    }\n\n    let k = (16 * c - l4) as u64 >> 51;\n\n    assert(\n        16 * p() - as_nat(limbs) - p() * k + as_nat(limbs)\n        ==\n        p() * (16 - k)\n    ) by {\n        lemma_mul_is_distributive_sub(p() as int, 16, k as int)\n    }\n\n    assert((p() * (16 - k)) as nat % p() == 0) by {\n        assert(k <= 16) by {\n            assert(k <= (16 * pow2(51)) as u64 >> 51) by {\n                lemma_shr_le_u64((16 * c - l4) as u64, (16 * pow2(51)) as u64, 51);\n            }\n            // 16 * 2^51 / 2^51 = 16\n            assert(((16 * 0x8000000000000) as u64 >> 51) == 16) by (compute);\n        }\n        lemma_mod_multiples_basic((16 - k) as int, p() as int);\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}