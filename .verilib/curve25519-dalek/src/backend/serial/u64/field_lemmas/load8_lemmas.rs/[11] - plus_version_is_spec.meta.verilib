{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/load8_at_spec",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec_is_bounded",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec_lemma"
  ],
  "disabled": false,
  "fingerprint": "33ae5cc9b5a74fd55732cda94e82115a62f9ce60266a225958d5a9aa00fea205",
  "id": 460219,
  "identifier": "plus_version_is_spec",
  "index": 11,
  "parent_id": 460207,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn plus_version_is_spec(input: &[u8], i: usize)\n    ensures\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n        load8_at_spec(input, i)\n{\n    assert(load8_at_plus_version_rec(input, i, 0) == input[i as int] as u64);\n\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert((input[i as int] as u64) == pow2(0 * 8) * input[i + 0]) by {\n            lemma2_to64();\n        }\n    plus_version_is_spec_lemma(input, i, 1);\n    plus_version_is_spec_lemma(input, i, 2);\n    plus_version_is_spec_lemma(input, i, 3);\n    plus_version_is_spec_lemma(input, i, 4);\n    plus_version_is_spec_lemma(input, i, 5);\n    plus_version_is_spec_lemma(input, i, 6);\n    plus_version_is_spec_lemma(input, i, 7);\n\n    // suffices to prove this, the _lemma results then give the spec formulation for free\n    assert(\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n         (input[i as int] as u64)\n        + ((input[i + 1] as u64) << 8)\n        + ((input[i + 2] as u64) << 16)\n        + ((input[i + 3] as u64) << 24)\n        + ((input[i + 4] as u64) << 32)\n        + ((input[i + 5] as u64) << 40)\n        + ((input[i + 6] as u64) << 48)\n        + ((input[i + 7] as u64) << 56)\n    ) by {\n        assert forall |j: nat| 1 <= j <= 7 implies\n        #[trigger] load8_at_plus_version_rec(input, i, j)\n        ==\n        load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n        by {\n            reveal_with_fuel(load8_at_plus_version_rec, 1);\n\n            assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8) <= u64::MAX) by {\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) <= pow2(8 * j) - 1 ) by {\n                    load8_at_plus_version_rec_is_bounded(input, i, (j - 1) as nat);\n                }\n\n                assert((input[i + j] as u64) << j * 8 <= u8::MAX * pow2(j * 8) ) by {\n                    // input[k] < MAX8 => input[k] * 2^(8j) < MAX8 * 2^(8j)\n                    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n                }\n\n                assert(\n                    load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n                    <=\n                    pow2(8 * (j + 1)) - 1\n                ) by {\n                    lemma_mul_is_distributive_add(1, u8::MAX as int, pow2(j * 8) as int);\n                }\n            }\n\n        }\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}