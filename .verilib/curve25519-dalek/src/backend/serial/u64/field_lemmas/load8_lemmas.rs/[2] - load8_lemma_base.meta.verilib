{
  "code_name": "mod.rs",
  "dependencies": [],
  "disabled": false,
  "fingerprint": "621d9ed8695434058ef8e0e5964eb89acf0c3363f73054f61a517cdc7f24f135",
  "id": 460210,
  "identifier": "load8_lemma_base",
  "index": 2,
  "parent_id": 460207,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma_base",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn load8_lemma_base(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64\n    ensures\n        a + (b * pow2(j)) == pow2(k) * (a / pow2(k) + (b * pow2(j)) as nat / pow2(k)) + (a % pow2(k) + (b * pow2(j)) as nat % pow2(k)),\n        pow2(k) > 0,\n{\n    let cb = (b * pow2(j)) as nat;\n\n    // No div by 0\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert( a == pow2(k) * (a / pow2(k)) + a % pow2(k)) by {\n        lemma_fundamental_div_mod(a as int, pow2(k) as int);\n    }\n\n    assert( cb == pow2(k) * (cb / pow2(k)) + cb % pow2(k)) by {\n        lemma_fundamental_div_mod(cb as int, pow2(k) as int);\n    }\n\n    assert(a + cb == pow2(k) * (a / pow2(k) + cb / pow2(k)) + (a % pow2(k) + cb % pow2(k))) by {\n        lemma_mul_is_distributive_add( pow2(k) as int, (a / pow2(k)) as int, (cb / pow2(k)) as int);\n        lemma_mul_is_associative(\n            (pow2(k) * (a / pow2(k) + cb / pow2(k))) as int,\n            (a % pow2(k)) as int,\n            (cb % pow2(k)) as int\n        );\n    }\n\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}