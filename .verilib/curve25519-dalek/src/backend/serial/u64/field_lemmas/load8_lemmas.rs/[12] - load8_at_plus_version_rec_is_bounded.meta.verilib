{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec"
  ],
  "disabled": false,
  "fingerprint": "63654020f9a640683584f69d5e26b9a3c3273e5fd94c76eeb99a789f71584102",
  "id": 460220,
  "identifier": "load8_at_plus_version_rec_is_bounded",
  "index": 12,
  "parent_id": 460207,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec_is_bounded",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1))\n    decreases k\n{\n\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    }\n    else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(\n                            c as int,\n                            pow2(8) as int,\n                            pow2(8 * k) as int\n                        );\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(\n                            pow2(8 * k) as int,\n                            pow2(56) as int,\n                            pow2(8) as int\n                        );\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k +1))) by {\n            // x + c * x == c ( x + 1 )\n            assert( pow2(8 * k) + c * pow2(8 * k) == pow2(8 *k) * (c + 1) ) by {\n                lemma_mul_is_distributive_add( pow2(8 * k) as int, c as int, 1 );\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality(\n                    (c + 1) as int,\n                    pow2(8) as int,\n                    pow2(8 * k) as int\n                );\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}