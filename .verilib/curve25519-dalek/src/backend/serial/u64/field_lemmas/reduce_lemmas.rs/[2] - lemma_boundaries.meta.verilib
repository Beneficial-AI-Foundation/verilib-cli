{
  "code_name": "vartime_double_base.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_lt",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shifted_lt",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/masked_lt_51"
  ],
  "disabled": false,
  "fingerprint": "a89c736e3ca4112265f361eec786fcfb8c48c6755bea11816754d2b1115d3e09",
  "id": 460206,
  "identifier": "lemma_boundaries",
  "index": 2,
  "parent_id": 460203,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_boundaries",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}