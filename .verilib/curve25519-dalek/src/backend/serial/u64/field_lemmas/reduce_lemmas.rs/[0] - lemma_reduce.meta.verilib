{
  "code_name": "vartime_double_base.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_boundaries",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_div_and_mod_51",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
    "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_two_factoring_51"
  ],
  "disabled": false,
  "fingerprint": "1ceffddffe651b0d8022b6881aaff05005454ac49c0e3b1c27abc6be3fdb37c9",
  "id": 460204,
  "identifier": "lemma_reduce",
  "index": 0,
  "parent_id": 460203,
  "path": "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & mask51\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & mask51 == limbs[i] by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & mask51);\n    let b1 = (limbs[1] & mask51);\n    let b2 = (limbs[2] & mask51);\n    let b3 = (limbs[3] & mask51);\n    let b4 = (limbs[4] & mask51);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}