{
  "code_name": "pow_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded"
  ],
  "disabled": false,
  "fingerprint": "5707b0dcd6ca0b21fd9c0c7990639240377161d723a754e9710326474ad4a1cc",
  "id": 460305,
  "identifier": "lemma_sub_loop1_invariant",
  "index": 4,
  "parent_id": 460300,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop1_invariant",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_sub_loop1_invariant(difference: Scalar52, borrow: u64, i: usize, a: &Scalar52, b: &Scalar52, old_borrow: u64, mask: u64, difference_loop1_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                    seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64)\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) -\n        (seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(52 * i as nat) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n        (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52) + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat) -\n                        0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64<<12) - 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        assert( 0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(52 * (i + 1) as nat) ) by\n                        {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(pow2(52 * (i+1) as nat) as int, (1u64<<12) - 1, (1u64 << 12) as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (-1) * pow2(52 * (i+1) as nat) ; {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n            else {\n\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert (borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}