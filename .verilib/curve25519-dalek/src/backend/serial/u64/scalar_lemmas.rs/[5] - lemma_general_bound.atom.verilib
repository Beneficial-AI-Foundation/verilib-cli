pub proof fn lemma_general_bound(a: Seq<u64>)
    requires forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52)
    ensures seq_u64_to_nat(a) < pow2((52 * a.len() as nat))
    decreases a.len()
{
    if a.len() == 0 {
        assert(seq_u64_to_nat(a) == 0);
        lemma2_to64(); // Gives us pow2(0) == 1 among other facts
        assert(pow2(0) == 1);
    } else {
        // Inductive case
        let tail = a.subrange(1, a.len() as int);

        // Apply induction hypothesis on tail
        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {
            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);
        };

        assert(tail.len() == a.len() - 1);

        // Apply induction hypothesis
        lemma_general_bound(tail);
        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));

        // Now prove for the full sequence
        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));
        assert(a.map(|i, x| x as nat).len() == a.len());
        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);
        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(1, a.len() as int).map(|i, x| x as nat));
        // Therefore:
        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int)) * pow2(52));

        assert(a.subrange(1, a.len() as int) == tail);

        // From precondition
        assert(a[0] < (1u64 << 52));
        lemma2_to64_rest();
        assert(0x10000000000000 == 1u64 << 52) by (compute_only);
        assert(0x10000000000000 == pow2(52));
        assert((1u64 << 52) == pow2(52));

        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)
        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))


        assert(a[0] as nat <= pow2(52) - 1);
        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);

        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52)) by {
            lemma_mul_inequality((pow2(52 * (a.len() - 1) as nat) - 1) as int, pow2(52 * (a.len() - 1) as nat) as int, pow2(52) as int);
        };

        // Expand the right side
        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) ==
               pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {
            broadcast use lemma_mul_is_distributive_sub;
        };

        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) ==
               pow2(52 * (a.len() - 1) as nat) * pow2(52) - 1);

        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);
        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));
        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);

        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);
        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));
    }
}