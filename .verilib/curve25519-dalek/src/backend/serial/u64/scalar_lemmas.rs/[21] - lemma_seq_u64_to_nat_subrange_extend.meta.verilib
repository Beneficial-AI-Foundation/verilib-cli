{
  "code_name": "pow_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat"
  ],
  "disabled": false,
  "fingerprint": "ef9931c4cb882998f2ebacaba01a05fb1a22921e7e8502e846e8a7593530ecc0",
  "id": 460322,
  "identifier": "lemma_seq_u64_to_nat_subrange_extend",
  "index": 21,
  "parent_id": 460300,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_seq_u64_to_nat_subrange_extend",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) ==\n        seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)\n    decreases i\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len()>0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(nat_single.subrange(1, 1)) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {lemma2_to64();}\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return;\n    }\n    else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert( seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(1, limbs1.len() as int));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i-1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i-1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) ==\n                    seq_u64_to_nat(tail.subrange(0, i - 1)) + tail[i -1 ] * pow2(52 * (i-1) as nat));\n                assert( tail.subrange(0, i) == seq.subrange(1, i + 1) );\n                assert( tail.subrange(0, i - 1) == seq.subrange(1, i ) );\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) ==\n                    seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat)) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * (i-1) as nat) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n                lemma_pow2_adds(52 * (i-1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert(seq.subrange(1, i ).map(|i, x| x as nat) == limbs2.subrange(1, limbs2.len() as int));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert( seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {\n            }\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n\n        }\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}