pub(crate) proof fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)
    requires
        0 <= i < 5,
        mask == (1u64 << 52) - 1,
        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),
        forall|j: int| i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],
        forall|j: int| (0 <= j < 5 && j!=i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],
        mask == (1u64 << 52) - 1,
        i == 0 ==> old_carry == 0,
        i >= 1 ==> (old_carry >> 52) < 2,
        (i >=1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i-1],
        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,
        borrow >> 63 == 1 ==>
            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==
            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(52 * i as nat),
        difference.limbs[i as int] == carry & mask,
        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),
        borrow >> 63 == 0 ==> addend == 0,
        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],
        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,
    ensures
        (i+1 >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],
        borrow >> 63 == 0 ==> difference_after_loop1 == difference,
        borrow >> 63 == 1 ==>
            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1 as int)) ==
            seq_u64_to_nat(difference.limbs@.subrange(0, i+1 as int)) + (carry >> 52) * pow2(52 * (i+1) as nat)
{
    if borrow >> 63 == 0 {
        lemma_old_carry(old_carry);
        assert(addend == 0);
        assert(carry == difference_loop2_start.limbs[i as int]);
        assert( carry & mask == carry ) by (bit_vector)
            requires
            carry < 1u64 <<52,
            mask == (1u64 << 52) - 1;
        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);
        assert(forall |j :int| 0<=j<5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);
        assert(difference_after_loop1.limbs == difference.limbs);
    }
    if borrow >> 63 == 1 {
        // When underflow, addend = L.limbs[i]
        assert(addend == constants::L.limbs[i as int]);
        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]
        // difference.limbs[i] = carry & mask
        calc! {
            (==)
            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1)); {
                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);
                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);
            }
            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat) +
            seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {
                broadcast use lemma_mul_is_distributive_add_other_way;
            }
            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) +
            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {
                // Use invariant
            }
            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +
            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {
                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int) );
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +
            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {
                broadcast use lemma_mul_is_distributive_add_other_way;
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat +
            difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {
                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int] + constants::L.limbs[i as int]);
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(52 * i as nat); {
                assert(carry == (carry >> 52) * (1u64<<52) + (carry & mask)) by (bit_vector)
                    requires mask == (1u64 << 52) - 1;
                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {
                    lemma2_to64_rest();
                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);};
                    assert(difference.limbs[i as int] == carry & mask);
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {
                broadcast use lemma_mul_is_distributive_add_other_way;
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {
                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};
                assert(52 + 52 * i as nat == 52 * (i+1) as nat);
                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {
                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));
                        lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);
                };
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {
                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);
            }
            seq_u64_to_nat(difference.limbs@.subrange(0, i+1)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat);
        }
    }
}