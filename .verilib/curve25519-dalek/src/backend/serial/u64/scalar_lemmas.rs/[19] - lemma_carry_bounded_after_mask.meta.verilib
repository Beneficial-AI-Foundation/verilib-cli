{
  "code_name": "pow_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
  ],
  "disabled": false,
  "fingerprint": "200631c13382ed7514a6ba25262c9efa232abc58a5340abb14839af0de9cdb25",
  "id": 460320,
  "identifier": "lemma_carry_bounded_after_mask",
  "index": 19,
  "parent_id": 460300,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_carry_bounded_after_mask",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}