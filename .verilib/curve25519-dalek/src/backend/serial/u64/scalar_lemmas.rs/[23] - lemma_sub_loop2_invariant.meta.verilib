{
  "code_name": "pow_lemmas.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
    "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_old_carry"
  ],
  "disabled": false,
  "fingerprint": "415076dccd6ed6a9bfae3821158b105fd6c6db7c32f7c38ac1290d86b209cfe2",
  "id": 460324,
  "identifier": "lemma_sub_loop2_invariant",
  "index": 23,
  "parent_id": 460300,
  "path": "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop2_invariant",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub(crate) proof fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int| i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int| (0 <= j < 5 && j!=i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >=1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i-1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i+1 >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1 as int)) ==\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1 as int)) + (carry >> 52) * pow2(52 * (i+1) as nat)\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert( carry & mask == carry ) by (bit_vector)\n            requires\n            carry < 1u64 <<52,\n            mask == (1u64 << 52) - 1;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall |j :int| 0<=j<5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1)); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat) +\n            seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int) );\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat +\n            difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int] + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(52 * i as nat); {\n                assert(carry == (carry >> 52) * (1u64<<52) + (carry & mask)) by (bit_vector)\n                    requires mask == (1u64 << 52) - 1;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);};\n                    assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                        lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat);\n        }\n    }\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}