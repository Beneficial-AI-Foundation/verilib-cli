{
  "code_name": "mod.rs",
  "dependencies": [],
  "disabled": false,
  "fingerprint": "7e6fe8615c0337acaf37369e8762044091495d1f3614e53d5a55bf0c73bc1d83",
  "id": 460279,
  "identifier": "reduce",
  "index": 13,
  "parent_id": 460265,
  "path": "/curve25519-dalek/src/backend/serial/u64/field.rs/reduce",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}