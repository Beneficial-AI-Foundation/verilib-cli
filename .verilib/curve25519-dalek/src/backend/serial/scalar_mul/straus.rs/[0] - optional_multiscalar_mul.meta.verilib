{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
    "/curve25519-dalek/src/window.rs/from"
  ],
  "disabled": false,
  "fingerprint": "df7ce2d600244dcd8a5d542828ac8f5b8fcdba12664fd1edd6d59a91ee822dfd",
  "id": 460343,
  "identifier": "optional_multiscalar_mul",
  "index": 0,
  "parent_id": 460342,
  "path": "/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs/optional_multiscalar_mul",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}