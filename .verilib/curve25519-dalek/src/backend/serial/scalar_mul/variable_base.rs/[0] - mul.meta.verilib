{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
    "/curve25519-dalek/src/scalar.rs/as_radix_16",
    "/curve25519-dalek/src/edwards.rs/identity",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended"
  ],
  "disabled": false,
  "fingerprint": "36cd96c5d883bbaaede41e4bcbcd9c331acd530a09c114000823e57bcf24c659",
  "id": 460334,
  "identifier": "mul",
  "index": 0,
  "parent_id": 460333,
  "path": "/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs/mul",
  "snippets": [
    {
      "sortorder": 0,
      "text": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}