{
  "code_name": "CLAUDE.md",
  "dependencies": [
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
    "/curve25519-dalek/src/window.rs/from",
    "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double"
  ],
  "disabled": false,
  "fingerprint": "aeff1e551d254d76dfab8598a2125614b3eec7725c38d8d46be0d20f3981882a",
  "id": 460336,
  "identifier": "optional_mixed_multiscalar_mul",
  "index": 0,
  "parent_id": 460335,
  "path": "/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/optional_mixed_multiscalar_mul",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}