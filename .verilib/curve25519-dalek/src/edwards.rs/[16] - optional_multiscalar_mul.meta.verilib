{
  "code_name": "constants.rs",
  "dependencies": [
    "/curve25519-dalek/src/backend/mod.rs/pippenger_optional_multiscalar_mul",
    "/curve25519-dalek/src/backend/mod.rs/straus_optional_multiscalar_mul"
  ],
  "disabled": false,
  "fingerprint": "db540e2abd95af49407e36e6d234debe4a3b34a41a0fd2b35451fe35ad947505",
  "id": 460391,
  "identifier": "optional_multiscalar_mul",
  "index": 16,
  "parent_id": 460374,
  "path": "/curve25519-dalek/src/edwards.rs/optional_multiscalar_mul",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}