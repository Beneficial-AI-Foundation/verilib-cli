{
  "code_name": "field.rs",
  "dependencies": [
    "/curve25519-dalek/src/montgomery.rs/differential_add_and_double",
    "/curve25519-dalek/src/montgomery.rs/as_affine",
    "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
    "/curve25519-dalek/src/montgomery.rs/identity"
  ],
  "disabled": false,
  "fingerprint": "ca498bcfc7de8e6b0246d1fb6340a7dfaa3913f0f68ec9dcf3a2c36805b27200",
  "id": 460007,
  "identifier": "mul_bits_be",
  "index": 8,
  "parent_id": 459998,
  "path": "/curve25519-dalek/src/montgomery.rs/mul_bits_be",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        // #[cfg(feature = \"zeroize\")]\n        // prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}