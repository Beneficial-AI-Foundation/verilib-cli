{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/scalar.rs/montgomery_invert",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
    "/curve25519-dalek/src/scalar.rs/unpack",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/as_montgomery",
    "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_montgomery",
    "/curve25519-dalek/src/scalar.rs/pack"
  ],
  "disabled": false,
  "fingerprint": "a1088f8b23bb6051d1e2c51c8490c4a59b883f668b10ef1edd6a23441995f29c",
  "id": 460039,
  "identifier": "batch_invert",
  "index": 19,
  "parent_id": 460019,
  "path": "/curve25519-dalek/src/scalar.rs/batch_invert",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // Zeroize::zeroize(&mut scratch);\n\n        ret\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}