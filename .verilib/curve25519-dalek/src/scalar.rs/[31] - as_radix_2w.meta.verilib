{
  "code_name": "mod.rs",
  "dependencies": [
    "/curve25519-dalek/src/scalar.rs/as_radix_16",
    "/curve25519-dalek/src/scalar.rs/read_le_u64_into"
  ],
  "disabled": false,
  "fingerprint": "f9145adfbb4680fc74d9ae4eebd34c49e282a66e058c36997b0fecaf0ca7b2c5",
  "id": 460051,
  "identifier": "as_radix_2w",
  "index": 31,
  "parent_id": 460019,
  "path": "/curve25519-dalek/src/scalar.rs/as_radix_2w",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}