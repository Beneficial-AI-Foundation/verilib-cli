{
  "code_name": "ristretto.rs",
  "dependencies": [],
  "disabled": false,
  "fingerprint": "d70e432808b9f912a6ada410a0c74e823fa5d6a1ccd68418232d10d34d2030ba",
  "id": 460492,
  "identifier": "new",
  "index": 7,
  "parent_id": 460484,
  "path": "/curve25519-dalek/src/traits.rs/new",
  "snippets": [
    {
      "sortorder": 0,
      "text": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
      "type_id": 2
    }
  ],
  "specified": false,
  "statement_type": "function",
  "status_id": 0
}