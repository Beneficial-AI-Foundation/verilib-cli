//! Configuration management for verilib structure.

use super::executor::{CommandConfig, ExecutionMode};
use crate::constants::DEFAULT_DOCKER_IMAGE;
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

/// Configuration for structure files stored in .verilib/config.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructureConfig {
    #[serde(rename = "structure-root")]
    pub structure_root: String,
    #[serde(default, rename = "execution-mode")]
    pub execution_mode: ExecutionMode,
    #[serde(default = "default_docker_image", rename = "docker-image")]
    pub docker_image: String,
}

fn default_docker_image() -> String {
    DEFAULT_DOCKER_IMAGE.to_string()
}

/// Computed paths derived from config.
#[derive(Debug, Clone)]
pub struct ConfigPaths {
    pub verilib_path: PathBuf,
    pub structure_root: PathBuf,
    pub structure_json_path: PathBuf,
    pub atoms_path: PathBuf,
    pub certs_specify_dir: PathBuf,
    pub command_config: CommandConfig,
}

impl StructureConfig {
    /// Create a new config with the given structure root.
    pub fn new(root: &str) -> Self {
        Self {
            structure_root: root.to_string(),
            execution_mode: ExecutionMode::Local,
            docker_image: default_docker_image(),
        }
    }

    /// Save config to .verilib/config.json
    pub fn save(&self, project_root: &Path) -> Result<PathBuf> {
        let verilib_path = project_root.join(".verilib");
        std::fs::create_dir_all(&verilib_path).context("Failed to create .verilib directory")?;

        let config_path = verilib_path.join("config.json");

        // If config exists, merge with existing content
        // We read it into a Value to preserve other fields, but we should also respect our own fields.
        let mut json: serde_json::Value = if config_path.exists() {
             let existing = std::fs::read_to_string(&config_path)
                .context("Failed to read existing config.json")?;
             serde_json::from_str(&existing).unwrap_or(serde_json::json!({}))
        } else {
             serde_json::json!({})
        };

        // Update fields
        json["structure-root"] = serde_json::Value::String(self.structure_root.clone());
        json["execution-mode"] = serde_json::to_value(&self.execution_mode).unwrap_or(serde_json::Value::Null);
        json["docker-image"] = serde_json::Value::String(self.docker_image.clone());

        let content = serde_json::to_string_pretty(&json).context("Failed to serialize config")?;
        std::fs::write(&config_path, content).context("Failed to write config.json")?;

        Ok(config_path)
    }
}

/// Create .gitignore for generated files in .verilib directory.
pub fn create_gitignore(verilib_path: &Path) -> Result<()> {
    let gitignore_path = verilib_path.join(".gitignore");
    if !gitignore_path.exists() {
        let gitignore_content =
            "# Generated by VeriLib (not tracked)\natoms.json\nspecs.json\nstubs.json\nproofs.json\n";
        std::fs::write(&gitignore_path, gitignore_content)
            .context("Failed to write .gitignore")?;
        println!("Created .verilib/.gitignore");
    }
    Ok(())
}

impl ConfigPaths {
    /// Load config and compute all paths.
    /// Requires structure-root to be present in config.
    pub fn load(project_root: &Path) -> Result<Self> {
        let verilib_path = project_root.join(".verilib");
        let config_path = verilib_path.join("config.json");

        if !config_path.exists() {
            anyhow::bail!(
                "{} not found. Run 'verilib-cli create' first.",
                config_path.display()
            );
        }

        let content =
            std::fs::read_to_string(&config_path).context("Failed to read config.json")?;

        let json: serde_json::Value =
            serde_json::from_str(&content).context("Failed to parse config.json")?;

        let structure_root_str = json
            .get("structure-root")
            .and_then(|v| v.as_str())
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "No 'structure-root' field in config.json. Run 'verilib-cli create' first."
                )
            })?;

        let structure_root = project_root.join(structure_root_str);

        // Parse Execution Config
        // 1. Defaults
        let mut mode = ExecutionMode::Local;
        let mut docker_image = default_docker_image();

        // 2. Config File
        if let Some(m) = json.get("execution-mode").and_then(|v| v.as_str()) {
            if m.eq_ignore_ascii_case("docker") {
                mode = ExecutionMode::Docker;
            } else if m.eq_ignore_ascii_case("local") {
                mode = ExecutionMode::Local;
            }
        }
        if let Some(img) = json.get("docker-image").and_then(|v| v.as_str()) {
            docker_image = img.to_string();
        }

        // 3. Environment Variables (Override)
        if let Ok(env_mode) = std::env::var("VERILIB_EXECUTION_MODE") {
            if env_mode.eq_ignore_ascii_case("docker") {
                mode = ExecutionMode::Docker;
            } else if env_mode.eq_ignore_ascii_case("local") {
                mode = ExecutionMode::Local;
            }
        }
        if let Ok(env_img) = std::env::var("VERILIB_DOCKER_IMAGE") {
            docker_image = env_img;
        }

        let command_config = CommandConfig {
            execution_mode: mode,
            docker_image,
        };

        Ok(Self {
            structure_root,
            structure_json_path: verilib_path.join("stubs.json"),
            atoms_path: verilib_path.join("atoms.json"),
            certs_specify_dir: verilib_path.join("certs").join("specs"),
            verilib_path,
            command_config,
        })
    }
}

