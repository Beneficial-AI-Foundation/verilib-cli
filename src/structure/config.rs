//! Configuration management for verilib structure.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

/// Configuration for structure files stored in .verilib/config.json
/// This contains only the structure-root field.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructureConfig {
    #[serde(rename = "structure-root")]
    pub structure_root: String,
}

/// Computed paths derived from config.
#[derive(Debug, Clone)]
pub struct ConfigPaths {
    pub verilib_path: PathBuf,
    pub structure_root: PathBuf,
    pub structure_json_path: PathBuf,
    pub atoms_path: PathBuf,
    pub certs_specify_dir: PathBuf,
}

impl StructureConfig {
    /// Create a new config with the given structure root.
    pub fn new(root: &str) -> Self {
        Self {
            structure_root: root.to_string(),
        }
    }

    /// Save config to .verilib/config.json
    /// This only writes the structure-root field.
    pub fn save(&self, project_root: &Path) -> Result<PathBuf> {
        let verilib_path = project_root.join(".verilib");
        std::fs::create_dir_all(&verilib_path).context("Failed to create .verilib directory")?;

        let config_path = verilib_path.join("config.json");

        // If config exists, merge with existing content
        let content = if config_path.exists() {
            let existing = std::fs::read_to_string(&config_path)
                .context("Failed to read existing config.json")?;
            let mut json: serde_json::Value =
                serde_json::from_str(&existing).unwrap_or(serde_json::json!({}));

            // Set structure-root
            json["structure-root"] = serde_json::Value::String(self.structure_root.clone());

            serde_json::to_string_pretty(&json).context("Failed to serialize config")?
        } else {
            serde_json::to_string_pretty(self).context("Failed to serialize config")?
        };

        std::fs::write(&config_path, content).context("Failed to write config.json")?;

        Ok(config_path)
    }
}

/// Create .gitignore for generated files in .verilib directory.
pub fn create_gitignore(verilib_path: &Path) -> Result<()> {
    let gitignore_path = verilib_path.join(".gitignore");
    if !gitignore_path.exists() {
        let gitignore_content =
            "# Generated by VeriLib (not tracked)\natoms.json\nspecs.json\nstubs.json\nproofs.json\n";
        std::fs::write(&gitignore_path, gitignore_content)
            .context("Failed to write .gitignore")?;
        println!("Created .verilib/.gitignore");
    }
    Ok(())
}

impl ConfigPaths {
    /// Load config and compute all paths.
    /// Requires structure-root to be present in config.
    pub fn load(project_root: &Path) -> Result<Self> {
        let verilib_path = project_root.join(".verilib");
        let config_path = verilib_path.join("config.json");

        if !config_path.exists() {
            anyhow::bail!(
                "{} not found. Run 'verilib-cli create' first.",
                config_path.display()
            );
        }

        let content =
            std::fs::read_to_string(&config_path).context("Failed to read config.json")?;

        let json: serde_json::Value =
            serde_json::from_str(&content).context("Failed to parse config.json")?;

        let structure_root_str = json
            .get("structure-root")
            .and_then(|v| v.as_str())
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "No 'structure-root' field in config.json. Run 'verilib-cli create' first."
                )
            })?;

        let structure_root = project_root.join(structure_root_str);

        Ok(Self {
            structure_root,
            structure_json_path: verilib_path.join("stubs.json"),
            atoms_path: verilib_path.join("atoms.json"),
            certs_specify_dir: verilib_path.join("certs").join("specs"),
            verilib_path,
        })
    }
}
