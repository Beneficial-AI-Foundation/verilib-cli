//! General utility functions for verilib structure.

use crate::executor::{self as executor, CommandConfig, ExternalTool};
use anyhow::{Context, Result};
use serde_json::Value;
use std::collections::HashSet;
use std::io::{self, BufRead, Write};
use std::path::Path;

/// Clean up generated intermediate files from probe-verus commands.
///
/// Removes common intermediate files and the data directory if empty.
pub fn cleanup_intermediate_files(project_root: &Path, files: &[&str]) {
    for file in files {
        let path = project_root.join(file);
        if path.exists() {
            let _ = std::fs::remove_file(&path);
        }
    }

    // Remove data directory
    let data_dir = project_root.join("data");
    if data_dir.exists() && data_dir.is_dir() {
        let _ = std::fs::remove_dir_all(&data_dir);
    }
}

/// Run an external tool's command and return its output.
///
/// Checks tool availability (and Docker availability when in Docker mode)
/// before executing. Pass [`ExternalTool::Probe`] for `probe-verus` commands.
pub fn run_command(
    tool: &ExternalTool,
    args: &[&str],
    cwd: Option<&Path>,
    config: &CommandConfig,
) -> Result<std::process::Output> {
    executor::run_command(tool, args, cwd, config)
}

/// Display a multiple choice menu and get user selections.
pub fn display_menu<F>(items: &[(String, Value)], format_item: F) -> Result<Vec<usize>>
where
    F: Fn(usize, &str, &Value) -> String,
{
    println!();
    println!("{}", "=".repeat(60));
    println!("Functions with specs but no certification:");
    println!("{}", "=".repeat(60));
    println!();

    for (i, (name, info)) in items.iter().enumerate() {
        println!("{}", format_item(i + 1, name, info));
        println!();
    }

    println!("{}", "=".repeat(60));
    println!();
    println!("Enter selection:");
    println!("  - Individual numbers: 1, 3, 5");
    println!("  - Ranges: 1-5");
    println!("  - 'all' to select all");
    println!("  - 'none' or empty to skip");
    println!();

    print!("Your selection: ");
    io::stdout().flush()?;

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input)?;
    let input = input.trim().to_lowercase();

    if input.is_empty() || input == "none" {
        return Ok(vec![]);
    }

    if input == "all" {
        return Ok((0..items.len()).collect());
    }

    let mut selected = HashSet::new();
    for part in input.replace(',', " ").split_whitespace() {
        if part.contains('-') {
            let parts: Vec<&str> = part.splitn(2, '-').collect();
            if parts.len() == 2 {
                if let (Ok(start), Ok(end)) = (parts[0].parse::<usize>(), parts[1].parse::<usize>())
                {
                    for i in start..=end {
                        if i >= 1 && i <= items.len() {
                            selected.insert(i - 1);
                        }
                    }
                } else {
                    eprintln!("Warning: Invalid range '{}', skipping", part);
                }
            }
        } else if let Ok(idx) = part.parse::<usize>() {
            if idx >= 1 && idx <= items.len() {
                selected.insert(idx - 1);
            } else {
                eprintln!("Warning: {} out of range, skipping", idx);
            }
        } else {
            eprintln!("Warning: Invalid number '{}', skipping", part);
        }
    }

    let mut result: Vec<usize> = selected.into_iter().collect();
    result.sort();
    Ok(result)
}

/// Get a display name from a full identifier (e.g., extract "func" from "probe:crate/mod#func()").
pub fn get_display_name(name: &str) -> String {
    if let Some(pos) = name.rfind('#') {
        name[pos + 1..].trim_end_matches("()").to_string()
    } else {
        name.to_string()
    }
}


/// Create .gitignore for generated files in .verilib directory.
pub fn create_gitignore(verilib_path: &Path) -> Result<()> {
    let gitignore_path = verilib_path.join(".gitignore");
    if !gitignore_path.exists() {
        let gitignore_content =
            "# Generated by VeriLib (not tracked)\natoms.json\nspecs.json\nstubs.json\nproofs.json\n";
        std::fs::write(&gitignore_path, gitignore_content)
            .context("Failed to write .gitignore")?;
        println!("Created .verilib/.gitignore");
    }
    Ok(())
}
